---
title: 重读unicorn
date: 2017-05-24 21:52:04
tags:
---

第一次读`Unicorn`是刚刚开始接触图计算这个领域的时候，囫囵吞枣地把这篇Paper看了一遍，对于其中的内容也没有特别的感觉，主要是当时资历尚欠。一个多月前，我们的架构师同学建议我再读一读这篇Paper，说起其中很多值得借鉴的地方。过了一年多，在这个领域或多或少有些经验了，希望这次能够有不同的感受。

## unicorn是什么？

简而言之，`Unicorn`是Facebook的一个在线的、全内存的图索引系统。所谓在线，即一般的请求在百毫秒内返回，全内存的设计也是服务与此；它支持在社交网络上进行高效的查询，来提升传统搜索引擎面对图结构时的不足；它只是一个索引系统，而不是一个『图数据库』。

Facebook的社交网络中有百亿级别的顶点、万亿级别的边。所有顶点都有64位的唯一ID，边更是有上千种类型，既可以有向也可以无向。图中存在一些热点，但是整体比较稀疏，大部分节点的边在1000以下。

## 数据模型

刚才提到，`Unicorn`中存的图是十分稀疏的，因此很自然地采用了『邻接表』的形式来存储图结构。`Unicorn`的查询语言把`<edge-type>:<id>`这样的结构称作`Term`，即某个点的某种类型的邻接点。比如，ID为8的用户的所有朋友写作：`friend:8`。每个`Term`对应着系统中的一个邻接表，而系统为每个点的每种类型的边维护这么一个邻接表。邻接表中的每个元素是一个邻接点，用`(sort-key, id, hit-data)`三元组。其中：

- `sort-key`表示这个这个点的全局rank值，在所有包含该点的邻接表中都是一样的；
- `id`就是邻接点的ID；
- `hit-data`可有可无，一般会包含一些用于过滤的属性数据；




{% asset_img data-model.png 数据模型（图片来自unicorn论文） %}




从数据结构来看，`Unicorn`可以看做是『Topylogy-Only』的，点上没有任何属性，边上也只有需要参与查询的属性。这一点与常见的『[属性图](https://github.com/tinkerpop/blueprints/wiki/Property-Graph-Model)』模型有着很大的区别，**`Unicorn`是更加纯粹的面向搜索场景的『索引系统』**。

另外，`unicorn`中的边是『按照终点分区』的，也就是说，查询某个点的所有出边需要到所有包含这种类型的边的机器上进行查询。这样做有两个好处：

1. 大部分的集合操作都能够下推到最底层的的所有节点执行，避免了把数据捞回到Aggregator上操作。比如『找用户A和B都赞过的照片』，由于边是按照终点（也就是照片）切分，所有赞过某张照片的边都会在同一个分区中，那么全局的操作就等价于在所有分区上执行该操作的结果的集合。**这一点可以极大减少数据传输量**。
2. 如果有节点宕机，也能是返回部分结果的，在搜索的场景中**『部分结果优于没有结果』**。

那么问题就来了，如果我既要查『小明给哪些照片点赞了』又要查『这张照片都被那些人点赞了』怎么办？`unicorn`的解法是，创建两种类型的边`likes`和`likers`。之前也提到，点边都是没有属性的，所以数据冗余的代价不会特别夸张。

## 系统架构

{% asset_img sys-arch.png 系统架构（图片来自unicorn论文） %}

从下往上看：

1. 不同类型的边的数据是放在不同的`vertical`中的，比如，用户相关的在user vertical，应用相关的在app vertical。
2. 不同的`vertical`相互独立，有不同的分区数和副本数。
3. 每个机架内有Aggregator和Index Server，即存储计算混部。
4. 最上层有Top Aggregator负责接收请求，拆分后路由到不同的`vertical`执行。

有意思的是，`unicorn`中不同的数据类型有不同的分区方式和副本策略，甚至是可以独立运维的。相对于图计算中的各种全图统一分区算法，有着鲜明的特色。这样做的好处是：

1. 充分考虑业务的多样性。不同的业务数据规模、访问流量都不一样，分开管理在运维上是最有效的方式。
2. 社交网络中的查询一般会指向少量的数据类型，因此分开带来的额外网络开销可以忽略。

## 查询语言

`unicorn`基于`s-express`构建查询语言，查询操作主要以集合操作(`AND`/`OR`/`DIFFRENCE`)和`Term`表达式为主，比如：

- `(and friends:5 gender:1)`：用户`5`的所有男性朋友
- `(or friends:5 friends:6)`：用户`6`的所有好友
- `(difference (and friends:5 gender:1) friends:6)`：用户`5`的所有男性朋友中不是用户`6`好友的人

当然，这上面的都不够亮眼，以下才是：

### Weak-And与Strong-Or
举个例子，用户`3`搜索一个名字以`mel`开头的用户，我们期望返回给他的结果集中既有他的朋友，也有不是他的朋友的人。通过`and`语句是无法做到的，于是`unicorn`引入了`weak-and`，允许一定程度上不满足`and`条件的结果出现。这是为了兼顾搜索的相关性和结果的多样性。

同理，`strong-or`的引入允许`or`条件中的某一部分在最终结果集中不小于某个比例，这也是为了兼顾结果的多样性。比如，搜索用户`5`居住在北京或者上海的朋友。如果北京的结果集就填满了最终结果集，这样的搜索质量是不高的。

### Apply

为了实现图遍历，`unicorn`引入了`apply`操作符。例如：`(apply tagged: friend:5)`表示查找用户`5`的朋友标记过的图片。首先执行的是`friends:5`，每一个结果都被『apply』到`tagged:`上进行图上的第二度扩展。

因为`unicorn`的面临的在线低延迟场景，很多`apply`查询也就一层而已。所以现对于`Gremlin`/`Cypher`等语言强劲的表达能力，`apply`可以说是不多不少，恰好够用。它至少让用户不用与后端多次交互来实现图的遍历，整个查询下沉到后端，对于简化应用逻辑、优化执行效率都是有好处的。

### Extract

`extract`操作是另外一个有意思的事情。社交图谱中有一类典型的模式是：海量小关系。比如，系统中几十亿张图片，每张图片上有若干个被标记的用户。按照一般的做法，会在photo vertical中保存用户到图片的『拥有』关系，在user vertical中保存图片到用户的『被标记』关系。如此一来，所有同一个PhotoId会在多个用户的`tagged:`邻接表中出现，同时还伴有`sort-key`和`hit-data`等数据结构，数据膨胀想当可观。

`unicorn`的巧妙之处在于，在photo vertical中通过一个正排索引保存了photo到user的`tagged:`关系，通过`extract`操作去查询正排索引，相当于把`tagged:`关系『内联』到了photo vertical中。这样做既节省了空间，又简化了查询过程，一举多得。

这对我们的启发很重要，保存拓扑关系的方式不止一种，根据数据的特性使用最合适的方式是可以同时达到时空的最优的。

## 总结

`unicorn`中有意思之处不仅限于上述几点，还有物化频繁查询的多度关系、多度查询的第一度按rank截断、多级Aggregator等等。这些特点带有鲜明的在线系统和搜索场景的特征。可以说，是场景造就了系统。同时，物化多度关系、内联简单关系等手段，也是其他图场景可以借鉴的地方。

在看过了很多图数据库和离线图计算系统之后，再回过头来看`unicorn`得到的最大启发是：场景！场景！场景！

目前『图』的场景还是一片蓝海，场景此岸是延时、彼岸是吞吐，海上一定会有连接两岸许多点分别切入各自的场景。同时，结构化与非结构化、精确关系代数与模糊查询、完备表达能力与业务裁剪之间的关系都是值得去思索和探究。
